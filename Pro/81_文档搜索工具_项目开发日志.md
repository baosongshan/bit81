<h1 align=center> 文档快速搜索神器 项目 开发日志 </h1>
<h2 align=center> 第一天 </h2>
### 一、项目介绍
>1、见【开发文档】

### 二、项目框架
>创建工程，给出Common.h  Sysutil.h\Sysutil.cpp DocFastSearchTool.cpp 模块

### 三、在系统工具模块中 实现目录遍历函数
```c++
void DirectionList(const string &path, vector<string> &subfile, vector<string> &subdir)
{
	string _path = path;  //"C:\\Users\\baoso\\Desktop\\Pro_81\\my_dir"
	_path += "\\*.*";     //"C:\\Users\\baoso\\Desktop\\Pro_81\\my_dir\\*.*";

	_finddata_t file;
	long handle = _findfirst(_path.c_str(), &file); //搜索path路劲下的第一个文件
	if(handle == -1)
	{
		perror("_findfirst");  //日志系统
		return;
	}

	do
	{
		if(strcmp(file.name,".")==0 || strcmp(file.name,"..")==0) //skip . and ..
			continue;

		if(file.attrib & _A_SUBDIR) 
		{
			//目录
            //cout<<file.name<<endl;
			//string tmp_path = path; 
			//tmp_path += "\\";      
			//tmp_path += file.name; 
			//DirectionList(tmp_path);
			subdir.push_back(file.name);
		}
		else
			//cout<<file.name<<endl;
			subfile.push_back(file.name);
	}while(_findnext(handle, &file) == 0);

	_findclose(handle);
}
```
### 四、数据库 sqlite 安装、使用

>1、安装
>```
>在 Windows 上安装 SQLite
>请访问 SQLite 下载页面，从 Windows 区下载预编译的二进制文件。
>您需要下载 sqlite-tools-win32-*.zip 和 sqlite-dll-win32-*.zip 压缩文件。
>创建文件夹 C:\sqlite，并在此文件夹下解压上面两个压缩文件，将得到 sqlite3.def、sqlite3.dll 和 sqlite3.exe 文件。
>添加 C:\sqlite 到 PATH 环境变量，最后在命令提示符下，使用 sqlite3 命令，将显示如下结果。
>```
>2、创建数据库
>```
>sqlite3 database_name.db    //创建
>.databases                  //显示数据库
>```
>3、创建表
>```
>CREATE TABLE doc_tb(
>id integer primary key autoincrement,
>name varchar(20),
>path varchar(100)
>);
>
>//查看表
>.tables
>```
>4、插入数据
>
>```
>insert into doc_tb values(1, "abc", "c:\\");
>```
>5、查询数据
>```
>select * from doc_tb;
>```

### 五 、数据库程序使用
>1、源码调用 [直接引用sqlite3.h 和sqlite3.c]
>2、静态库调用 #include"sqlite3.h"    #pragma comment(lib, "sqlite3.lib")
>3、sqlite3的API使用
>```
>https://www.runoob.com/sqlite/sqlite-c-cpp.html
>```

<h2 align=center> 第二天 </h2>
### 一 、增加DataManager模块
>1、Sqlite3的封装
>```c++
>//DataManager.h
>class SqliteManager
>{
>public:
>	SqliteManager();
>	~SqliteManager();
>public:
>	void Open(const string &path);
>	void Close();
>	void ExecuteSql(const string &sql);
>	void GetResultTable(const string &sql, int &row, int &col, char **&ppRet);
>private:
>	sqlite3 *m_db;
>};
>
>//DataManager.cpp
>//静态库
>#pragma comment(lib, "./sqlite/sqlite3.lib")
>
>SqliteManager::SqliteManager() : m_db(nullptr)
>{}
>SqliteManager::~SqliteManager()
>{
>	Close();
>}
>
>void SqliteManager::Open(const string &path)
>{
>	char *zErrMsg = 0;
>	int rc;
>	rc = sqlite3_open(path.c_str(), &m_db);
>	if (rc)
>	{
>		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(m_db));
>		exit(0);
>	}
>	else
>	{
>		fprintf(stderr, "Opened database successfully\n");
>	}
>}
>void SqliteManager::Close()
>{
>	if(m_db)
>	{
>		int rc = sqlite3_close(m_db);
>		if(rc != SQLITE_OK)
>		{
>			fprintf(stderr, "Close database failed: %s\n", sqlite3_errmsg(m_db));
>		}
>		else
>			fprintf(stderr, "Close database successfully\n");
>	}
>}
>
>void SqliteManager::ExecuteSql(const string &sql)
>{
>	char *zErrMsg = 0;
>	int rc = sqlite3_exec(m_db, sql.c_str(), 0, 0, &zErrMsg);
>	if (rc != SQLITE_OK)
>	{
>		fprintf(stderr, "SQL(%s) error: %s\n", sql.c_str(),zErrMsg);
>		sqlite3_free(zErrMsg);
>	}
>	else
>	{
>		fprintf(stdout, "SQL(%s) Execute successfully.\n", sql.c_str());
>	}
>}
>
>void SqliteManager::GetResultTable(const string &sql, int &row, int &col, char **&ppRet)
>{
>	char *zErrMsg = 0;
>	int rc = sqlite3_get_table(m_db, sql.c_str(), &ppRet, &row, &col, &zErrMsg);
>	if(rc != SQLITE_OK)
>	{
>		fprintf(stdout, "Get Result Table error: %s\n", zErrMsg);
>	}
>	else
>	{
>		fprintf(stdout, "Get Result Table successfully.\n", zErrMsg);
>	}
>}
>```
>2、在Sysutil.h中增减日志模块
>```c++
>#ifndef __TRACE__
>	//#define __TRACE__
>#endif
>
>#ifndef __DEBUG__
>	#define __DEBUG__
>#endif
>
>///////////////////////////////////////////////////////////////////////
>static std::string GetFileName(const std::string& path)
>{
>	char ch = '/';
>
>#ifdef _WIN32
>	ch = '\\';
>#endif
>	size_t pos = path.rfind(ch);
>	if (pos == std::string::npos)
>		return path;
>	else
>		return path.substr(pos + 1);
>}
>
>//用于调试追溯的trace log
>inline static void __TraceDebug(const char* filename, int line, const char* function, const char* format, ...)
>{
>#ifdef __TRACE__
>	//输出调用函数的信息
>	fprintf(stdout,"[TRACE][%s:%d:%s]:",GetFileName(filename).c_str(), line, function);
>
>	//输出用户打的trace信息
>	va_list args;
>	va_start(args,format);
>	vfprintf(stdout,format, args);
>	va_end(args);
>
>	fprintf(stdout,"\n");
>#endif
>}
>
>inline static void __ErrorDebug(const char* filename, int line, const char* function, const char* format, ...)
>{
>#ifdef __DEBUG__
>	//输出调用函数的信息
>	fprintf(stdout,"[ERROR][%s:%d:%s]:",GetFileName(filename).c_str(), line, function);
>
>	//输出用户打的trace信息
>	va_list args;
>	va_start(args,format);
>	vfprintf(stdout,format, args);
>	va_end(args);
>
>	fprintf(stdout," errmsg:%s, errno:%d\n", strerror(errno), errno);
>#endif
>}
>
>#define TRACE_LOG(...) \
>	__TraceDebug(__FILE__, __LINE__, __FUNCTION__, __VA_ARGS__);
>
>#define ERROR_LOG(...) \
>	__ErrorDebug(__FILE__, __LINE__, __FUNCTION__, __VA_ARGS__);
>```
>3、增加DataManager 管理类
>```c++
>//DataManager.h
>class DataManager
>{
>public:
>	DataManager();
>	~DataManager();
>public:
>	void InitSqlite();
>public:
>	void InsertDoc(const string &path, const string &doc);
>	void GetDocs(const string &path, multiset<string> &docs);
>	void DeleteDoc(const string &path, const string &doc);
>private:
>	SqliteManager m_dbmgr;
>};
>
>///////////////////////////////////////////////////////////////////////////////
>//DataManager.cpp
>DataManager::DataManager()
>{
>	m_dbmgr.Open(DOC_DB);
>	InitSqlite();
>}
>DataManager::~DataManager()
>{}
>
>void DataManager::InitSqlite()
>{
>	char sql[SQL_BUFFER_SIZE] = {0};
>	sprintf(sql, "create table if not exists %s(id integer primary key autoincrement, doc_name text, doc_path text)", DOC_TABLE);
>	m_dbmgr.ExecuteSql(sql);
>}
>
>void DataManager::InsertDoc(const string &path, const string &doc)
>{
>	char sql[SQL_BUFFER_SIZE] = {0};
>	sprintf(sql, "insert into %s values(null, '%s', '%s')",DOC_TABLE, doc.c_str(), path.c_str());
>	//insert into %s values(null, stl.pdf, c:\\)
>	m_dbmgr.ExecuteSql(sql);
>}
>void DataManager::GetDocs(const string &path, multiset<string> &docs)
>{
>	char sql[SQL_BUFFER_SIZE] = {0};
>	sprintf(sql, "select doc_name from %s where doc_path='%s'", DOC_TABLE, path.c_str());
>
>	int row=0, col=0;
>	char **ppRet = 0;
>	m_dbmgr.GetResultTable(sql, row, col, ppRet);
>
>	for(int i=1; i<=row; ++i)
>		docs.insert(ppRet[i]);
>
>	//释放结果表
>	sqlite3_free_table(ppRet);
>}
>void DataManager::DeleteDoc(const string &path, const string &doc)
>{
>	char sql[SQL_BUFFER_SIZE] = {0};
>	sprintf(sql, "delete from %s where doc_name='%s' and doc_path='%s'", DOC_TABLE, doc.c_str(), path.c_str());
>	m_dbmgr.ExecuteSql(sql);
>
>	///////////////////////////////////////////
>}
>```
>4、增加扫描模块  ScanManager模块
>```c++
>//ScanManager.h
>class ScanManager
>{
>public:
>	void ScanDirectory(const string &path);
>private:
>	DataManager m_db;
>};
>
>///////////////////////////////////////////////////////////////////////////////
>//ScanManager.cpp
>void ScanManager::ScanDirectory(const string &path)
>{
>	//1 扫描本地文件系统
>	vector<string> local_files;  //subfiles
>	vector<string> local_dirs;   //subdirs
>	DirectionList(path, local_files, local_dirs);
>	set<string> local_set;
>	local_set.insert(local_files.begin(), local_files.end());
>	local_set.insert(local_dirs.begin(), local_dirs.end());
>
>	//2 扫描数据库文件系统
>	multiset<string> db_set;
>	m_db.GetDocs(path, db_set);
>
>	//3 对比本地文件与数据库文件
>	auto local_it = local_set.begin();
>	auto db_it = db_set.begin();
>	while(local_it!=local_set.end() && db_it!=db_set.end())
>	{
>		if(*local_it < *db_it)
>		{
>			//本地文件存在，数据库文件不存在，则数据库新增文件
>			m_db.InsertDoc(path, *local_it);
>			local_it++;
>		}
>		else if(*local_it > *db_it)
>		{
>			//本地文件不存在，数据库文件存在，则数据库删除文件
>			m_db.DeleteDoc(path, *db_it);
>			db_it++;
>		}
>		else
>		{
>			//本地文件存在，数据库文件存在，则数据库文件不需要改变
>			local_it++;
>			db_it++;
>		}
>	}
>
>	while(local_it != local_set.end())
>	{
>		//本地文件存在，数据库文件不存在，则数据库新增文件
>		m_db.InsertDoc(path, *local_it);
>		local_it++;
>	}
>	while(db_it != db_set.end())
>	{
>		//本地文件不存在，数据库文件存在，则数据库删除文件
>		m_db.DeleteDoc(path, *db_it);
>		db_it++;
>	}
>
>	//递归遍历子目录
>	//
>}
>```

<h2 align=center> 第三天 </h2>
```

```
<h2 align=center> 第四天 </h2>
```

```



